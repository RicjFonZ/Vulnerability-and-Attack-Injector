package tools.controllers;

import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.TextArea;
import utilities.HandleFiles;

import java.io.File;
import java.io.FileNotFoundException;
import java.math.BigInteger;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.Formatter;
import java.util.ResourceBundle;
import java.util.Scanner;

public class EncoderToolController implements Initializable {

    static private final int EMPTY_TEXTAREA_LENGTH = 0;
    private final HandleFiles handleFiles = new HandleFiles();
    @FXML
    private Button encodeButton;
    @FXML
    private Button decodeButton;
    @FXML
    private TextArea plainTextArea;
    @FXML
    private TextArea encodeTextArea;
    @FXML
    private Button loadPlainTextBt;
    @FXML
    private Button savePlainTextBt;
    @FXML
    private Button loadEncodeTextBt;
    //    @FXML private TextField DelimiterTextBox;
//    @FXML private CheckBox TextCheckBox;
//    @FXML private CheckBox HexCheckBox;
//    @FXML private CheckBox UppercaseCheckBox;
    @FXML
    private Button saveEncodeTextButton;
    @FXML
    private ComboBox<String> methodComboBox;
    private String encodeResult;
    private String decodeResult;
    private String encodeMethod;
    private String plainText;
    private String encodeText;

    private static String byteToHex(final byte[] hash) {
        final Formatter formatter = new Formatter();
        for (final byte b : hash) {
            formatter.format("%02x", b);
        }
        final String result = formatter.toString();
        formatter.close();
        return result;
    }

    @Override
    public void initialize(final URL location, final ResourceBundle resources) {

        // Listener for all changes on text area to control visibility of buttons
        addListenerTextAreas();


        methodComboBoxAction();
        loadActions();
        saveActions();
        encodeDecodeActions();
    }

    private void addListenerTextAreas() {

        plainTextArea.textProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue.length() == EMPTY_TEXTAREA_LENGTH) {
                plainStateButtons(true);
            } else {
                plainStateButtons(false);
            }
        });

        encodeTextArea.textProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue.length() == EMPTY_TEXTAREA_LENGTH || methodComboBox.getValue().equals("MD5") || methodComboBox.getValue().equals("SHA1")) {
                encodeStateButtons(true);
            } else {
                encodeStateButtons(false);
            }
        });
    }

    private void encodeStateButtons(final boolean state) {
        decodeButton.setDisable(state);
        saveEncodeTextButton.setDisable(state);
    }

    private void plainStateButtons(final boolean state) {
        encodeButton.setDisable(state);
        savePlainTextBt.setDisable(state);
    }

    private void loadActions() {
        loadPlainTextBt.setOnAction(event -> openTxtFile(plainTextArea));

        loadEncodeTextBt.setOnAction(event -> openTxtFile(encodeTextArea));
    }

    private void openTxtFile(final TextArea textArea) {
        final File file = handleFiles.openFileDialog("TXT files (*.txt)", "*.txt", "Open Text File");
        if (file != null) {
            textArea.setText("");
            try {
                final Scanner s = new Scanner(file);
                while (s.hasNextLine()) {
                    final String a = s.nextLine();
                    textArea.appendText(a);
                }
            } catch (FileNotFoundException ex) {
                ex.printStackTrace();
            }
        }
    }

    private void encodeDecodeActions() {
        encodeButton.setOnAction(event -> {
            encodeMethod = methodComboBox.getValue();
            plainText = plainTextArea.getText();
            switch (encodeMethod) {
                case "Base 64":
                    encodeResult = base64Encode(plainText);
                    encodeTextArea.setText(encodeResult);
                    break;
                case "Hex":
                    encodeResult = hexEncode(plainText.getBytes());
                    encodeTextArea.setText(encodeResult);
                    break;
                case "HTTP":
                    encodeResult = httpEncode(plainText);
                    encodeTextArea.setText(encodeResult);
                    break;
                case "HTTP (Full)":
                    encodeResult = httpFullEncode(plainText);
                    break;
                case "Unicode":
                    encodeResult = unicodeEncode(plainText);
                    encodeTextArea.setText(encodeResult);
                    break;
                case "HTML (Simple)":
                    encodeResult = htmlEncode(plainText);
                    break;
                case "MD5":
                    encodeResult = md5Encode(plainText);
                    encodeTextArea.setText(encodeResult);
                    break;
                case "SHA1":
                    encodeResult = sha1Encode(plainText);
                    encodeTextArea.setText(encodeResult);
                    break;
                default:
                    encodeResult = base64Encode(plainText);
                    encodeTextArea.setText(encodeResult);
                    break;
            }
        });

        decodeButton.setOnAction(event -> {
            encodeMethod = methodComboBox.getValue();
            encodeText = encodeTextArea.getText();
            switch (encodeMethod) {
                case "Base 64":
                    decodeResult = base64Decode(encodeText);
                    plainTextArea.setText(decodeResult);
                    break;
                case "Hex":
                    decodeResult = hexDecode(encodeText);
                    plainTextArea.setText(decodeResult);
                    break;
                case "HTTP":
                    decodeResult = httpDecode(encodeText);
                    plainTextArea.setText(decodeResult);
                    break;
                case "HTTP (Full)":
                    encodeResult = httpFullEncode(plainText);
                    break;
                case "Unicode":
                    decodeResult = unicodeDecode(encodeText);
                    plainTextArea.setText(decodeResult);
                    break;
                case "HTML (Simple)":
                    encodeResult = htmlEncode(plainText);
                    break;
                default:
                    encodeResult = base64Encode(plainText);
                    encodeTextArea.setText(encodeResult);
                    break;
            }
        });
    }

    private void saveActions() {

        saveEncodeTextButton.setOnAction(event -> handleFiles.saveFile(
                "Text File",
                "*.txt",
                encodeTextArea,
                methodComboBox.getValue(),
                "Encode"));

        savePlainTextBt.setOnAction(event -> handleFiles.saveFile(
                "Text File",
                "*.txt",
                plainTextArea,
                methodComboBox.getValue(),
                "PlainText"));
    }

    private void methodComboBoxAction() {
        //Encode Decode Methods
        methodComboBox.getItems().addAll(
                "Base 64",
                "Hex",
                "HTTP",
                "HTTP (Full)",
                "Unicode",
                "HTML (Simple)",
                "MD5",
                "SHA1"
        );
        methodComboBox.getSelectionModel().selectFirst();

        methodComboBox.setOnAction(event -> {
            if (methodComboBox.getValue().equals("MD5") || methodComboBox.getValue().equals("SHA1")) {
                decodeButton.setDisable(true);
                loadEncodeTextBt.setDisable(true);
            } else {
                decodeButton.setDisable(false);
                loadEncodeTextBt.setDisable(false);
            }
        });
    }

    private String unescape(final String source) {
        final String unescapeText;
        final int i;
        final char ch;

        i = Integer.parseInt(source, 16);

        ch = (char) i;
        unescapeText = String.format("%s", ch);
        return unescapeText;
    }

    //MD5
    private String md5Encode(final String plainText) {
        String md5 = "";
        try {
            final MessageDigest mdEnc = MessageDigest.getInstance("MD5"); //Encryption algorithm
            mdEnc.update(plainText.getBytes(), 0, plainText.length());
            md5 = new BigInteger(1, mdEnc.digest()).toString(16); // Encrypted string
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return md5;
    }

    //SHA1
    private String sha1Encode(final String plainText) {
        String sha1 = "";
        try {
            final MessageDigest crypt = MessageDigest.getInstance("SHA-1");
            crypt.reset();
            crypt.update(plainText.getBytes(StandardCharsets.UTF_8));
            sha1 = byteToHex(crypt.digest());
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return sha1;
    }

    private String htmlEncode(final String plainText) {
        return plainText;
    }

    //UNICODE
    private String unicodeEncode(final String plainText) {
        int inLength;
        final String prechars = "%u";
        String uniTemp;
        final StringBuilder uniResult = new StringBuilder();
        String strResult = "";

        final int srcLen = plainText.length();

        // Cycle through each input character.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                inLength = Integer.toString(plainText.charAt(i), 16).length();

                final int zero = 0;
                if (inLength > zero) {
                    uniTemp = Integer.toHexString(plainText.charAt(i));

                    final int one = 1;
                    final int two = 2;
                    final int three = 3;
                    if (inLength == one) {
                        uniResult.append(prechars).append("000").append(uniTemp); // + delimiter;
                    } else if (inLength == two) {
                        uniResult.append(prechars).append("00").append(uniTemp); // + delimiter;
                    } else if (inLength == three) {
                        uniResult.append(prechars).append('0').append(uniTemp); // + delimiter;
                    } else {
                        uniResult.append(prechars).append(uniTemp); // + delimiter;
                    }

                } else {
                    uniResult.append(" [").append(plainText.charAt(i)).append(" Not Valid] "); // + delimiter;
                }
            }

            strResult = uniResult.toString();

        }
        return strResult;
    }

    private String unicodeDecode(final String encodeText) {

        final StringBuilder plainResult = new StringBuilder();

        final int srcLen = encodeText.length();
        final StringBuilder hex = new StringBuilder();
        int j;

        // Cycles through encoded text. Finds all instances of %XX and converts them
        // to the plain text equivalent.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                // Trailing characters present.

                final char percentage = '%';
                if (encodeText.charAt(i) == percentage) {
                    j = i + 2;
                    while (encodeText.charAt(j) != '%' && j < srcLen - 1) {
                        hex.append(encodeText, j, j + 1);
                        j++;
                    }
                    if (j == srcLen - 1) {
                        hex.append(encodeText, j, j + 1);
                        j++;
                    }
                    i = j - 1;
                    plainResult.append(unescape(hex.toString()));
                } else {
                    plainResult.append(encodeText.charAt(i));
                }
            }
        }

        return plainResult.toString();

    }

    private String httpFullEncode(final String plainText) {
        return plainText;
    }

    //HTTP
    private String httpEncode(final String plainText) {

        final String urlReg = "[a-zA-Z0-9$_.+!*~(),&/:;=?@#-']";
        final int srcLen = plainText.length();
        final StringBuilder urlResult = new StringBuilder();
        int inLength;

        String hex = "";

        // Cycle through each input character.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                inLength = Integer.toString(plainText.charAt(i), 16).length();

                // Leave character as is.
                if (plainText.substring(i, i + 1).matches(urlReg)) {
                    urlResult.append(plainText.charAt(i));

                    // Encode all other ASCII characters.
                } else if (plainText.charAt(i) < 128) {
                    hex = Integer.toHexString(plainText.charAt(i));

                    // Pad with zero for results < 10.
                    if (inLength == 1) {
                        urlResult.append("%0").append(hex);
                    } else if (inLength == 2) {
                        urlResult.append('%').append(hex);
                    }
                } else {
                    urlResult.append(hex);
                }
            }
        }

        return urlResult.toString();
    }

    private String httpDecode(final String encodeText) {

        final StringBuilder plainResult = new StringBuilder();
        final int srcLen = encodeText.length();
        String hex;

        // Cycles through encoded text. Finds all instances of %XX and converts them
        // to the plain text equivalent.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                // Trailing characters present.

                if (encodeText.charAt(i) == '%') {

                    hex = encodeText.substring(i + 1, i + 2) + encodeText.substring(i + 2, i + 3);
                    i = i + 2;
                    plainResult.append(unescape(hex));

                } else if (encodeText.charAt(i) == '+') {//The + sign is converted to a space
                    plainResult.append(" ");
                } else {
                    plainResult.append(encodeText.charAt(i));
                }
            }
        }
        return plainResult.toString();
    }

    //HEX
    private String hexEncode(final byte[] data) {
        final StringBuilder buf = new StringBuilder();
        for (final byte aData : data) {
            int halfByte = (aData >>> 4) & 0x0F;
            int twoHalf = 0;
            do {
                final int nine = 9;
                if (halfByte <= nine) {
                    buf.append((char) ('0' + halfByte));
                } else {
                    buf.append((char) ('a' + (halfByte - 10)));
                }
                halfByte = aData & 0x0F;
            } while (twoHalf++ < 1);
        }
        return buf.toString();
    }

    private String hexDecode(final String encodeText) {

        final StringBuilder output = new StringBuilder();

        for (int i = 0; i < encodeText.length(); i += 2) {
            String str = "";
            try {
                str = encodeText.substring(i, i + 2);
            } catch (Exception ex) {
                plainTextArea.clear();
                plainTextArea.appendText("Error while decoding Hex");
            }
            output.append((char) Integer.parseInt(str, 16));
        }
        return output.toString();
    }

    //BASE 64
    private String base64Encode(final String plainText) {
        return Base64.getEncoder().encodeToString(plainText.getBytes());
    }

    private String base64Decode(final String encodeText) {
        final byte[] asBytes = Base64.getDecoder().decode(encodeText);
        return new String(asBytes);
    }

}
