package tools.controllers;

import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import utilities.HandleFiles;

import java.io.*;
import java.math.BigInteger;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

public class EncoderToolController implements Initializable
{

    @FXML private Button EncodeButton;
    @FXML private Button DecodeButton;
    @FXML private TextArea PlainTextBox;
    @FXML private TextArea EncodeTextBox;
    @FXML private Button LoadPlainTextBt;
    @FXML private Button SavePlainTextBt;
    @FXML private Button LoadEncodeTextBt;
    @FXML private Button SaveEncodeTextButton;
    @FXML private ComboBox<String> MethodComboBox;
//    @FXML private TextField DelimiterTextBox;
//    @FXML private CheckBox TextCheckBox;
//    @FXML private CheckBox HexCheckBox;
//    @FXML private CheckBox UppercaseCheckBox;

    private String encodeResult;
    private String decodeResult;
    private String encodeMethod;
    private String plainText;
    private String encodeText;


    private final HandleFiles handleFiles = new HandleFiles();

    @Override
    public void initialize(final URL location, final ResourceBundle resources) {

        methodComboBoxAction();
        loadActions();
        saveActions();
        encodeDecodeActions();
    }

    private void loadActions() {
        LoadPlainTextBt.setOnAction(event -> {
            final File file = handleFiles.openFileDialog("TXT files (*.txt)","*.txt","Open Text File");
            if (file != null) {
                PlainTextBox.setText("");
                try {
                    final Scanner s = new Scanner(file);
                    while (s.hasNextLine()){
                        final String a = s.nextLine();
                        PlainTextBox.appendText(a+"\n");
                    }
                } catch (FileNotFoundException ex) {
                    System.err.println();
                }
        }});

        LoadEncodeTextBt.setOnAction(event -> {
            final File file = handleFiles.openFileDialog("TXT files (*.txt)","*.txt","Open Text File");
            if (file != null) {
                EncodeTextBox.setText("");
                try {
                    final Scanner s = new Scanner(file);
                    while (s.hasNextLine()){
                        final String a = s.nextLine();
                        EncodeTextBox.appendText(a+"\n");
                    }
                } catch (FileNotFoundException ex) {
                    System.err.println();
                }
            }});
    }

    private void encodeDecodeActions() {
        EncodeButton.setOnAction(event -> {
            encodeMethod = MethodComboBox.getValue();
            plainText = PlainTextBox.getText();
            switch (encodeMethod){
                case "Base 64":
                    encodeResult = base64Encode(plainText);
                    EncodeTextBox.setText(encodeResult);
                    break;
                case "Hex":
                    encodeResult = hexEncode(plainText.getBytes());
                    EncodeTextBox.setText(encodeResult);
                    break;
                case "HTTP":
                    encodeResult = httpEncode(plainText);
                    break;
                case "HTTP (Full)":
                    encodeResult = httpFullEncode(plainText);
                    break;
                case "Unicode":
                    encodeResult = unicodeEncode(plainText);
                    EncodeTextBox.setText(encodeResult);
                    break;
                case "HTML (Simple)":
                    encodeResult = htmlEncode(plainText);
                    break;
                case "MD5":
                    encodeResult = md5Encode(plainText);
                    EncodeTextBox.setText(encodeResult);
                    break;
                case "SHA1":
                    encodeResult = sha1Encode(plainText);
                    EncodeTextBox.setText(encodeResult);
                    break;
                default:
                    encodeResult = base64Encode(plainText);
                    EncodeTextBox.setText(encodeResult);
                    break;
            }
        });

        DecodeButton.setOnAction(event -> {
            encodeMethod = MethodComboBox.getValue();
            encodeText = EncodeTextBox.getText();
            switch (encodeMethod){
                case "Base 64":
                    decodeResult = base64Decode(encodeText);
                    PlainTextBox.setText(decodeResult);
                    break;
                case "Hex":
                    decodeResult = hexDecode(encodeText);
                    PlainTextBox.setText(decodeResult);
                    break;
                case "HTTP":
                    encodeResult = httpEncode(plainText);
                    break;
                case "HTTP (Full)":
                    encodeResult = httpFullEncode(plainText);
                    break;
                case "Unicode":
                    decodeResult = unicodeDecode(encodeText);
                    PlainTextBox.setText(decodeResult);
                    break;
                case "HTML (Simple)":
                    encodeResult = htmlEncode(plainText);
                    break;
                default:
                    encodeResult = base64Encode(plainText);
                    EncodeTextBox.setText(encodeResult);
                    break;
            }
        });
    }

    private void saveActions() {

        SaveEncodeTextButton.setOnAction(event -> handleFiles.saveFile(
                "Text File",
                "*.txt",
                EncodeTextBox,
                MethodComboBox.getValue(),
                "Encode"));

        SavePlainTextBt.setOnAction(event -> handleFiles.saveFile(
                "Text File",
                "*.txt",
                PlainTextBox,
                MethodComboBox.getValue(),
                "PlainText"));
    }

    private void methodComboBoxAction() {
        //Encode Decode Methods
        MethodComboBox.getItems().addAll(
                "Base 64",
                "Hex",
                "HTTP",
                "HTTP (Full)",
                "Unicode",
                "HTML (Simple)",
                "MD5",
                "SHA1"
        );
        MethodComboBox.getSelectionModel().selectFirst();

        MethodComboBox.setOnAction(event -> {
            if (MethodComboBox.getValue().equals("MD5") || MethodComboBox.getValue().equals("SHA1")){
                DecodeButton.setDisable(true);
                LoadEncodeTextBt.setDisable(true);
            }else {
                DecodeButton.setDisable(false);
                LoadEncodeTextBt.setDisable(false);
            }
        });
    }

    private String unicodeDecode(final String encodeText) {

        final StringBuilder plainResult = new StringBuilder();

        final int srcLen = encodeText.length();
        final StringBuilder hex = new StringBuilder();
        int j;

        // Cycles through encoded text. Finds all instances of %XX and converts them
        // to the plain text equivalent.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                // Trailing characters present.

                Character PERCENTAGE = '%';
                if (encodeText.charAt(i) == PERCENTAGE) {
                        j = i + 2;
                        while (encodeText.charAt(j) != '%' && j < srcLen - 1) {
                            hex.append(encodeText, j, j + 1);
                            j++;
                        }
                        if (j == srcLen - 1) {
                            hex.append(encodeText, j, j + 1);
                            j++;
                        }
                        i = j - 1;
                        plainResult.append(unescape(hex.toString()));
                    } else {
                        plainResult.append(encodeText.charAt(i));
                    }
                }
            }

        return plainResult.toString();

    }

    private String unescape(final String source) {
        final String unescapeText;
        final int i;
        final char ch;

        i = Integer.parseInt(source, 16);

        ch = (char) i;
        unescapeText = String.format("%s", ch);
        return unescapeText;
    }

    //MD5
    private String md5Encode(final String plainText) {
        final String md5;
        try {
            final MessageDigest mdEnc = MessageDigest.getInstance("MD5"); //Encryption algorithm
            mdEnc.update(plainText.getBytes(), 0, plainText.length());
            md5 = new BigInteger(1, mdEnc.digest()).toString(16); // Encrypted string
        }
        catch (Exception ex) {
            return null;
        }
        return md5;
    }

    //SHA1
    private String sha1Encode(final String plainText) {
        String sha1 = "";
        try
        {
            final MessageDigest crypt = MessageDigest.getInstance("SHA-1");
            crypt.reset();
            crypt.update(plainText.getBytes(StandardCharsets.UTF_8));
            sha1 = byteToHex(crypt.digest());
        }
        catch(NoSuchAlgorithmException e)
        {
            e.printStackTrace();
        }
        return sha1;
    }
    private static String byteToHex(final byte[] hash){
        final Formatter formatter = new Formatter();
        for (final byte b : hash)
        {
            formatter.format("%02x", b);
        }
        final String result = formatter.toString();
        formatter.close();
        return result;
    }

    private String htmlEncode(final String plainText) {
        return plainText;
    }

    private String unicodeEncode(final String plainText) {
        int inLength;
        final String prechars = "%u";
        String uniTemp;
        final StringBuilder uniResult = new StringBuilder();
        String strResult = "";

        final int srcLen = plainText.length();

        // Cycle through each input character.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                inLength = Integer.toString(plainText.charAt(i), 16).length();

                Integer ZERO = 0;
                if (inLength > ZERO) {
                    uniTemp = Integer.toHexString(plainText.charAt(i));

                    Integer ONE = 1;
                    Integer TWO = 2;
                    Integer THREE = 3;
                    if (inLength == ONE) {
                        uniResult.append(prechars).append("000").append(uniTemp); // + delimiter;
                    } else if (inLength == TWO) {
                        uniResult.append(prechars).append("00").append(uniTemp); // + delimiter;
                    } else if (inLength == THREE) {
                        uniResult.append(prechars).append('0').append(uniTemp); // + delimiter;
                    } else {
                        uniResult.append(prechars).append(uniTemp); // + delimiter;
                    }

                } else {
                    uniResult.append(" [").append(plainText.charAt(i)).append(" Not Valid] "); // + delimiter;
                }
            }

            strResult = uniResult.toString();

        }
        return strResult;
    }

    private String httpFullEncode(final String plainText) {
        return plainText;
    }

    private String httpEncode(final String plainText) {
        return plainText;
    }

    //HEX
    private String hexEncode(final byte[] data) {
        final StringBuilder buf = new StringBuilder();
        for (final byte aData : data) {
            int halfByte = (aData >>> 4) & 0x0F;
            int two_half = 0;
            do {
                Integer NINE = 9;
                if (halfByte <= NINE) {
                    buf.append((char) ('0' + halfByte));
                } else {
                    buf.append((char) ('a' + (halfByte - 10)));
                }
                halfByte = aData & 0x0F;
            } while (two_half++ < 1);
        }
        return buf.toString();
    }
    private String hexDecode(final String encodeText) {

        final StringBuilder output = new StringBuilder();

        for (int i = 0; i < encodeText.length(); i += 2) {
            final String str = encodeText.substring(i, i + 2);
            output.append((char) Integer.parseInt(str, 16));
        }
        return output.toString();
    }

    //BASE 64
    private String base64Encode(final String plainText) {
        return Base64.getEncoder().encodeToString(plainText.getBytes());
    }
    private String base64Decode(final String encodeText) {
        final byte[] asBytes = Base64.getDecoder().decode(encodeText);
        return new String(asBytes);
    }

}
