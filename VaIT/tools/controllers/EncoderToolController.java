package tools.controllers;

import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.TextArea;
import utilities.HandleFiles;

import java.io.File;
import java.io.FileNotFoundException;
import java.math.BigInteger;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.Formatter;
import java.util.ResourceBundle;
import java.util.Scanner;
import java.util.logging.Logger;


public class EncoderToolController implements Initializable
{

    @FXML private Button encodeButton;
    @FXML private Button decodeButton;
    @FXML private TextArea plainTextBox;
    @FXML private TextArea encodeTextBox;
    @FXML private Button loadPlainTextBt;
    @FXML private Button savePlainTextBt;
    @FXML private Button loadEncodeTextBt;
    @FXML private Button saveEncodeTextButton;
    @FXML private ComboBox<String> methodComboBox;
//    @FXML private TextField DelimiterTextBox;
//    @FXML private CheckBox TextCheckBox;
//    @FXML private CheckBox HexCheckBox;
//    @FXML private CheckBox UppercaseCheckBox;

    private String encodeResult;
    private String decodeResult;
    private String encodeMethod;
    private String plainText;
    private String encodeText;

    private final HandleFiles handleFiles = new HandleFiles();

    private Logger log = Logger.getLogger(EncoderToolController.class.getName());

    @Override
    public void initialize(final URL location, final ResourceBundle resources) {

        methodComboBoxAction();
        loadActions();
        saveActions();
        encodeDecodeActions();
    }

    private void loadActions() {
        loadPlainTextBt.setOnAction(event -> openTxtFile(plainTextBox));

        loadEncodeTextBt.setOnAction(event -> openTxtFile(encodeTextBox));
    }

    private void openTxtFile(final TextArea textArea) {
        final File file = handleFiles.openFileDialog("TXT files (*.txt)", "*.txt", "Open Text File");
        if (file != null) {
            textArea.setText("");
            try {
                final Scanner s = new Scanner(file);
                while (s.hasNextLine()) {
                    final String a = s.nextLine();
                    textArea.appendText(a + "\n");
                }
            } catch (FileNotFoundException ex) {
                log.fine(ex.getMessage());
            }
        }
    }

    private void encodeDecodeActions() {
        encodeButton.setOnAction(event -> {
            encodeMethod = methodComboBox.getValue();
            plainText = plainTextBox.getText();
            switch (encodeMethod){
                case "Base 64":
                    encodeResult = base64Encode(plainText);
                    encodeTextBox.setText(encodeResult);
                    break;
                case "Hex":
                    encodeResult = hexEncode(plainText.getBytes());
                    encodeTextBox.setText(encodeResult);
                    break;
                case "HTTP":
                    encodeResult = httpEncode(plainText);
                    break;
                case "HTTP (Full)":
                    encodeResult = httpFullEncode(plainText);
                    break;
                case "Unicode":
                    encodeResult = unicodeEncode(plainText);
                    encodeTextBox.setText(encodeResult);
                    break;
                case "HTML (Simple)":
                    encodeResult = htmlEncode(plainText);
                    break;
                case "MD5":
                    encodeResult = md5Encode(plainText);
                    encodeTextBox.setText(encodeResult);
                    break;
                case "SHA1":
                    encodeResult = sha1Encode(plainText);
                    encodeTextBox.setText(encodeResult);
                    break;
                default:
                    encodeResult = base64Encode(plainText);
                    encodeTextBox.setText(encodeResult);
                    break;
            }
        });

        decodeButton.setOnAction(event -> {
            encodeMethod = methodComboBox.getValue();
            encodeText = encodeTextBox.getText();
            switch (encodeMethod){
                case "Base 64":
                    decodeResult = base64Decode(encodeText);
                    plainTextBox.setText(decodeResult);
                    break;
                case "Hex":
                    decodeResult = hexDecode(encodeText);
                    plainTextBox.setText(decodeResult);
                    break;
                case "HTTP":
                    encodeResult = httpEncode(plainText);
                    break;
                case "HTTP (Full)":
                    encodeResult = httpFullEncode(plainText);
                    break;
                case "Unicode":
                    decodeResult = unicodeDecode(encodeText);
                    plainTextBox.setText(decodeResult);
                    break;
                case "HTML (Simple)":
                    encodeResult = htmlEncode(plainText);
                    break;
                default:
                    encodeResult = base64Encode(plainText);
                    encodeTextBox.setText(encodeResult);
                    break;
            }
        });
    }

    private void saveActions() {

        saveEncodeTextButton.setOnAction(event -> handleFiles.saveFile(
                "Text File",
                "*.txt",
                encodeTextBox,
                methodComboBox.getValue(),
                "Encode"));

        savePlainTextBt.setOnAction(event -> handleFiles.saveFile(
                "Text File",
                "*.txt",
                plainTextBox,
                methodComboBox.getValue(),
                "PlainText"));
    }

    private void methodComboBoxAction() {
        //Encode Decode Methods
        methodComboBox.getItems().addAll(
                "Base 64",
                "Hex",
                "HTTP",
                "HTTP (Full)",
                "Unicode",
                "HTML (Simple)",
                "MD5",
                "SHA1"
        );
        methodComboBox.getSelectionModel().selectFirst();

        methodComboBox.setOnAction(event -> {
            if (methodComboBox.getValue().equals("MD5") || methodComboBox.getValue().equals("SHA1")){
                decodeButton.setDisable(true);
                loadEncodeTextBt.setDisable(true);
            }else {
                decodeButton.setDisable(false);
                loadEncodeTextBt.setDisable(false);
            }
        });
    }

    private String unicodeDecode(final String encodeText) {

        final StringBuilder plainResult = new StringBuilder();

        final int srcLen = encodeText.length();
        final StringBuilder hex = new StringBuilder();
        int j;

        // Cycles through encoded text. Finds all instances of %XX and converts them
        // to the plain text equivalent.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                // Trailing characters present.

                final char percentage = '%';
                if (encodeText.charAt(i) == percentage) {
                        j = i + 2;
                        while (encodeText.charAt(j) != '%' && j < srcLen - 1) {
                            hex.append(encodeText, j, j + 1);
                            j++;
                        }
                        if (j == srcLen - 1) {
                            hex.append(encodeText, j, j + 1);
                            j++;
                        }
                        i = j - 1;
                        plainResult.append(unescape(hex.toString()));
                    } else {
                        plainResult.append(encodeText.charAt(i));
                    }
                }
            }

        return plainResult.toString();

    }

    private String unescape(final String source) {
        final String unescapeText;
        final int i;
        final char ch;

        i = Integer.parseInt(source, 16);

        ch = (char) i;
        unescapeText = String.format("%s", ch);
        return unescapeText;
    }

    //MD5
    private String md5Encode(final String plainText) {
        String md5 = "";
        try {
            final MessageDigest mdEnc = MessageDigest.getInstance("MD5"); //Encryption algorithm
            mdEnc.update(plainText.getBytes(), 0, plainText.length());
            md5 = new BigInteger(1, mdEnc.digest()).toString(16); // Encrypted string
        }
        catch (Exception ex) {
            log.fine(ex.getMessage());
        }
        return md5;
    }

    //SHA1
    private String sha1Encode(final String plainText) {
        String sha1 = "";
        try
        {
            final MessageDigest crypt = MessageDigest.getInstance("SHA-1");
            crypt.reset();
            crypt.update(plainText.getBytes(StandardCharsets.UTF_8));
            sha1 = byteToHex(crypt.digest());
        }
        catch(NoSuchAlgorithmException e)
        {
            e.printStackTrace();
        }
        return sha1;
    }
    private static String byteToHex(final byte[] hash){
        final Formatter formatter = new Formatter();
        for (final byte b : hash)
        {
            formatter.format("%02x", b);
        }
        final String result = formatter.toString();
        formatter.close();
        return result;
    }

    private String htmlEncode(final String plainText) {
        return plainText;
    }

    private String unicodeEncode(final String plainText) {
        int inLength;
        final String prechars = "%u";
        String uniTemp;
        final StringBuilder uniResult = new StringBuilder();
        String strResult = "";

        final int srcLen = plainText.length();

        // Cycle through each input character.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                inLength = Integer.toString(plainText.charAt(i), 16).length();

                final int zero = 0;
                if (inLength > zero) {
                    uniTemp = Integer.toHexString(plainText.charAt(i));

                    final int one = 1;
                    final int two = 2;
                    final int three = 3;
                    if (inLength == one) {
                        uniResult.append(prechars).append("000").append(uniTemp); // + delimiter;
                    } else if (inLength == two) {
                        uniResult.append(prechars).append("00").append(uniTemp); // + delimiter;
                    } else if (inLength == three) {
                        uniResult.append(prechars).append('0').append(uniTemp); // + delimiter;
                    } else {
                        uniResult.append(prechars).append(uniTemp); // + delimiter;
                    }

                } else {
                    uniResult.append(" [").append(plainText.charAt(i)).append(" Not Valid] "); // + delimiter;
                }
            }

            strResult = uniResult.toString();

        }
        return strResult;
    }

    private String httpFullEncode(final String plainText) {
        return plainText;
    }

    private String httpEncode(final String plainText) {
        return plainText;
    }

    //HEX
    private String hexEncode(final byte[] data) {
        final StringBuilder buf = new StringBuilder();
        for (final byte aData : data) {
            int halfByte = (aData >>> 4) & 0x0F;
            int two_half = 0;
            do {
                int NINE = 9;
                if (halfByte <= NINE) {
                    buf.append((char) ('0' + halfByte));
                } else {
                    buf.append((char) ('a' + (halfByte - 10)));
                }
                halfByte = aData & 0x0F;
            } while (two_half++ < 1);
        }
        return buf.toString();
    }
    private String hexDecode(final String encodeText) {

        final StringBuilder output = new StringBuilder();

        for (int i = 0; i < encodeText.length(); i += 2) {
            final String str = encodeText.substring(i, i + 2);
            output.append((char) Integer.parseInt(str, 16));
        }
        return output.toString();
    }

    //BASE 64
    private String base64Encode(final String plainText) {
        return Base64.getEncoder().encodeToString(plainText.getBytes());
    }
    private String base64Decode(final String encodeText) {
        final byte[] asBytes = Base64.getDecoder().decode(encodeText);
        return new String(asBytes);
    }

}
